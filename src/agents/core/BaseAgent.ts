import type { 
  BaseAgent, 
  AgentConfig, 
  AgentResult, 
  SharedContext 
} from '../../types/agents';
import type { SupportedAIModel } from '../../types/index';
import { getAIConfig } from '../../config/aiConfig';

export abstract class AbstractBaseAgent<TResult = any> implements BaseAgent<TResult> {
  public readonly name: string;
  public readonly config: AgentConfig;

  constructor(config: AgentConfig) {
    this.name = config.name;
    this.config = config;
  }

  // G≈Ç√≥wna metoda przetwarzania - musi byƒá zaimplementowana przez ka≈ºdy agent
  public async process(context: SharedContext): Promise<AgentResult<TResult>> {
    const startTime = Date.now();
    
    try {
      console.log(`üöÄ [${this.name}] Rozpoczynanie przetwarzania...`);
      
      // Sprawd≈∫ zale≈ºno≈õci
      this.validateDependencies(context);
      console.log(`‚úÖ [${this.name}] Zale≈ºno≈õci sprawdzone`);
      
      // Wykonaj logikƒô specyficznƒÖ dla agenta
      const result = await this.executeLogic(context);
      console.log(`‚úÖ [${this.name}] executeLogic zako≈Ñczone`, result);
      
      // Waliduj wynik
      const isValid = this.validate(result);
      if (!isValid) {
        console.error(`‚ùå [${this.name}] Walidacja nie powiod≈Ça siƒô:`, result);
        throw new Error(`Validation failed for agent ${this.name}`);
      }
      console.log(`‚úÖ [${this.name}] Walidacja zako≈Ñczona pomy≈õlnie`);
      
      const processingTime = Date.now() - startTime;
      
      return {
        agentName: this.name,
        data: result,
        confidence: this.calculateConfidence(result, context),
        warnings: this.generateWarnings(result, context),
        processingTime,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      const processingTime = Date.now() - startTime;
      
      console.error(`üí• [${this.name}] B≈ÅƒÑD podczas przetwarzania:`, error);
      console.error(`üí• [${this.name}] Stack trace:`, error instanceof Error ? error.stack : 'Brak stack trace');
      
      // Zwracamy fallback zamiast rzucaƒá b≈ÇƒÖd
      return {
        agentName: this.name,
        data: this.getErrorFallback(),
        confidence: 0,
        warnings: [`Error in ${this.name}: ${error instanceof Error ? error.message : 'Unknown error'}`],
        processingTime,
        timestamp: new Date().toISOString()
      };
    }
  }

  // Abstrakcyjne metody do implementacji przez konkretne agenty
  protected abstract executeLogic(context: SharedContext): Promise<TResult>;
  protected abstract getErrorFallback(): TResult;
  
  // Walidacja - domy≈õlna implementacja, mo≈ºe byƒá przes≈Çoniƒôta
  public validate(result: TResult): boolean {
    return result !== null && result !== undefined;
  }

  // Sprawdzenie zale≈ºno≈õci
  protected validateDependencies(context: SharedContext): void {
    if (!this.config.dependencies) return;
    
    for (const dependency of this.config.dependencies) {
      const contextKey = this.mapAgentNameToContextKey(dependency);
      if (!context[contextKey as keyof SharedContext]) {
        throw new Error(`Missing dependency: ${dependency} is required for ${this.name}`);
      }
    }
  }

  // Mapowanie nazw agent√≥w na klucze kontekstu
  private mapAgentNameToContextKey(agentName: string): string {
    const mapping: Record<string, string> = {
      'clinical-synthesis': 'clinicalSynthesis',
      'episode-analysis': 'episodeAnalysis',
      'pharmacotherapy-analysis': 'pharmacotherapyAnalysis',
      'trd-assessment': 'trdAssessment',
      'criteria-assessment': 'inclusionCriteriaAssessment',
      'risk-assessment': 'riskAssessment'
    };
    
    return mapping[agentName] || agentName;
  }

  // Obliczanie pewno≈õci - domy≈õlna implementacja
  protected calculateConfidence(_result: TResult, _context: SharedContext): number {
    // Domy≈õlnie zwracamy 0.8, ale ka≈ºdy agent mo≈ºe to przes≈Çoniƒá
    return 0.8;
  }

  // Generowanie ostrze≈ºe≈Ñ - domy≈õlna implementacja
  protected generateWarnings(_result: TResult, _context: SharedContext): string[] {
    return [];
  }

  // Pomocnicza metoda do wywo≈Çywania API AI z automatycznym fallback
  protected async callAI(userPrompt: string, systemPrompt: string, model: SupportedAIModel): Promise<string> {
    const backendUrl = 'http://localhost:3001';
    
    // Lista modeli do wypr√≥bowania w kolejno≈õci preferencji
    const modelFallbackChain: SupportedAIModel[] = [
      model, // Pierwotnie wybrany model
      'gemini', // Fallback 1: Gemini (ma wysokie limity)
      'o3' // Fallback 2: OpenAI o3 (jako ostateczno≈õƒá)
    ];
    
    // Usu≈Ñ duplikaty z listy fallback
    const uniqueModels = [...new Set(modelFallbackChain)];
    
    let lastError: Error | null = null;
    
    for (let i = 0; i < uniqueModels.length; i++) {
      const currentModel = uniqueModels[i];
      
      try {
        console.log(`üîÑ [${this.name}] Wysy≈Çanie ≈ºƒÖdania do backend proxy dla modelu: ${currentModel}${i > 0 ? ' (fallback)' : ''}`);
        
        const response = await fetch(`${backendUrl}/api/ai/chat`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: currentModel,
            systemPrompt,
            userPrompt,
            temperature: this.config.temperature,
            maxTokens: this.getMaxTokensForModel(currentModel)
          })
        });

        if (!response.ok) {
          const errorData = await response.json();
          const errorMessage = `Backend API Error (${currentModel}): ${response.status} - ${errorData.message || JSON.stringify(errorData)}`;
          
          // Sprawd≈∫ czy to b≈ÇƒÖd rate limit Claude
          const isClaudeRateLimit = currentModel === 'claude-opus' && 
            (response.status === 429 || 
             errorData.message?.includes('rate_limit_error') ||
             errorData.message?.includes('rate limit'));
          
          if (isClaudeRateLimit && i < uniqueModels.length - 1) {
            console.warn(`‚ö†Ô∏è [${this.name}] Claude rate limit detected, trying fallback model: ${uniqueModels[i + 1]}`);
            lastError = new Error(errorMessage);
            continue; // Spr√≥buj nastƒôpny model
          }
          
          throw new Error(errorMessage);
        }

        const data = await response.json();
        console.log(`‚úÖ [${this.name}] Otrzymano odpowied≈∫ z backend proxy dla modelu: ${currentModel}${i > 0 ? ' (fallback)' : ''}`);
        
        if (i > 0) {
          console.log(`üîÑ [${this.name}] U≈ºyto fallback model ${currentModel} zamiast ${model}`);
        }
        
        return data.content || '';
        
      } catch (error) {
        lastError = error as Error;
        console.error(`üí• [${this.name}] B≈ÅƒÑD podczas komunikacji z backend (${currentModel}):`, error);
        
        // Je≈õli to nie jest ostatni model w ≈Ça≈Ñcuchu, spr√≥buj nastƒôpny
        if (i < uniqueModels.length - 1) {
          console.log(`üîÑ [${this.name}] Pr√≥bujƒô fallback model: ${uniqueModels[i + 1]}`);
          continue;
        }
      }
    }
    
    // Je≈õli wszystkie modele zawiod≈Çy
    console.error(`üí• [${this.name}] Wszystkie modele fallback zawiod≈Çy. Ostatni b≈ÇƒÖd:`, lastError);
    
    // Sprawd≈∫ czy backend jest dostƒôpny
    if (lastError instanceof TypeError && lastError.message.includes('fetch')) {
      throw new Error(`Backend server is not running. Please start it with: npm run server`);
    }
    
    throw lastError || new Error('All AI models failed');
  }

  // Pomocnicza metoda do okre≈õlania maksymalnej liczby token√≥w dla r√≥≈ºnych modeli
  private getMaxTokensForModel(model: SupportedAIModel): number {
    switch (model) {
      case 'claude-opus':
        return Math.min(this.config.maxTokens || 32000, 32000); // Claude ma limit 32k
      case 'gemini':
        return Math.min(this.config.maxTokens || 65000, 65000); // Gemini ma wy≈ºszy limit
      case 'o3':
        return Math.min(this.config.maxTokens || 65000, 65000); // O3 ma wysokie limity
      default:
        return this.config.maxTokens || 32000;
    }
  }

  // Pomocnicza metoda do parsowania JSON z obs≈ÇugƒÖ b≈Çƒôd√≥w
  protected parseJSONResponse<T>(jsonString: string): T {
    try {
      console.log(`üîç [${this.name}] Parsowanie odpowiedzi JSON...`);
      
      // Usu≈Ñ bia≈Çe znaki na poczƒÖtku i ko≈Ñcu
      let cleanedString = jsonString.trim();
      
      // Znajd≈∫ i wytnij JSON z blok√≥w markdown ```json```
      const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/;
      const jsonMatch = cleanedString.match(jsonBlockRegex);
      
      if (jsonMatch) {
        cleanedString = jsonMatch[1].trim();
        console.log(`üîç [${this.name}] Znaleziono blok JSON w markdown`);
      } else {
        // Spr√≥buj znale≈∫ƒá JSON miƒôdzy nawiasami klamrowymi
        const jsonObjectRegex = /\{[\s\S]*\}/;
        const objectMatch = cleanedString.match(jsonObjectRegex);
        
        if (objectMatch) {
          cleanedString = objectMatch[0];
          console.log(`üîç [${this.name}] Znaleziono obiekt JSON w tek≈õcie`);
        }
      }
      
      // NAPRAW PROBLEM Z UNDEFINED - zamie≈Ñ na null
      cleanedString = cleanedString.replace(/:\s*undefined\b/g, ': null');
      cleanedString = cleanedString.replace(/,\s*undefined\b/g, ', null');
      cleanedString = cleanedString.replace(/\[\s*undefined\b/g, '[null');
      cleanedString = cleanedString.replace(/undefined\s*,/g, 'null,');
      cleanedString = cleanedString.replace(/undefined\s*\]/g, 'null]');
      
      console.log(`üîç [${this.name}] Oczyszczony JSON:`, cleanedString.substring(0, 200) + '...');
      
      try {
        const parsed = JSON.parse(cleanedString);
        console.log(`‚úÖ [${this.name}] JSON sparsowany pomy≈õlnie`);
        return parsed;
      } catch (parseError) {
        // PR√ìBA NAPRAWY: Je≈õli JSON jest uszkodzony, spr√≥buj obciƒÖƒá na ostatnim poprawnym miejscu
        console.log(`üîß [${this.name}] Pr√≥ba naprawy uszkodzonego JSON...`);
        
        // Znajd≈∫ ostatni poprawny nawias zamykajƒÖcy
        const lastValidBrace = this.findLastValidJsonEnd(cleanedString);
        if (lastValidBrace > 0) {
          const repairedJson = cleanedString.substring(0, lastValidBrace + 1);
          console.log(`üîß [${this.name}] Pr√≥ba parsowania naprawionego JSON (${repairedJson.length} znak√≥w)`);
          
          try {
            const parsed = JSON.parse(repairedJson);
            console.log(`‚úÖ [${this.name}] Naprawiony JSON sparsowany pomy≈õlnie`);
            return parsed;
          } catch (repairError) {
            console.log(`‚ùå [${this.name}] Naprawa JSON nie powiod≈Ça siƒô`);
          }
        }
        
        throw parseError;
      }
      
    } catch (error) {
      console.error(`üí• [${this.name}] B≈ÇƒÖd parsowania JSON:`, error);
      console.error(`üí• [${this.name}] Oryginalna odpowied≈∫:`, jsonString.substring(0, 500) + '...');
      throw new Error(`B≈ÇƒÖd parsowania odpowiedzi ${this.name}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Pomocnicza metoda do znajdowania ostatniego poprawnego ko≈Ñca JSON
  private findLastValidJsonEnd(jsonString: string): number {
    let braceCount = 0;
    let lastValidEnd = -1;
    
    for (let i = 0; i < jsonString.length; i++) {
      const char = jsonString[i];
      
      if (char === '{') {
        braceCount++;
      } else if (char === '}') {
        braceCount--;
        if (braceCount === 0) {
          lastValidEnd = i;
        }
      }
    }
    
    return lastValidEnd;
  }
} 